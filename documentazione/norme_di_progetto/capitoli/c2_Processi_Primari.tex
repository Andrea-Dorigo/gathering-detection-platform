\chapter{Processi Primari}\label{ProcessiPrimari}
\section{Fornitura}\label{ProcessiPrimariFornitura}
\subsection{Scopo}\label{ProcessiPrimariFornituraScopo}
La fornitura secondo lo standard ISO/IEC 12207:1995 descrive le attività$_G$ e i compiti svolti dal fornitore al fine di sviluppare un prodotto soddisfacente e che rispetti appieno le richieste del committente$_G$.
Durante questa fase si prevede la compilazione di diversi documenti, i quali verranno inviati al committente$_{\scaleto{G}{3pt}}$ per guadagnare la possibilità di lavorare al progetto offerto dall'azienda \textit{Sync Lab}.
Il fornitore esegue un'attività$_{\scaleto{G}{3pt}}$ di analisi e stesura dello \textit{Studio di Fattibilità}, documento che rileva i rischi e le criticità riscontrate nella richiesta di appalto.
Si definisce inoltre un accordo contrattuale con il proponente$_G$ mediante il quale si regolano i rapporti con l'azienda, la consegna e la manutenzione del prodotto sviluppato.

\subsection{Studio di Fattibilità}\label{ProcessiPrimariFornituraStudioDiFattibilità}
Lo \textit{Studio di Fattibilità} consiste nell'analisi e nella valutazione sistematica delle caratteristiche, dei costi, e dei possibili risultati di un progetto sulla base di una preliminare idea di massima.
A seguito della presentazione dei capitolati d'appalto da parte di ogni proponente$_{\scaleto{G}{3pt}}$ avvenuta il 05-11-2020, il \textit{Responsabile di Progetto} si è impegnato a programmare incontri con tutti i componenti del gruppo \textit{Jawa Druids} per valutare le scelte di ogni membro e attuare così un primo scambio di idee. Una volta individuato il capitolato d'interesse gli \textit{Analisti} hanno provveduto alla stesura dello \textit{Studio di Fattibilità}, i quali hanno fornito un'analisi accurata dei capitolati presentati.
Nella stesura dello \textit{Studio di Fattibilità} per ogni capitolato$_{\scaleto{G}{3pt}}$ si riporterà:
\begin{itemize}
	\item informazioni generali: informazioni riguardanti il proponente$_{\scaleto{G}{3pt}}$;
	\item descrizione del capitolato$_{\scaleto{G}{3pt}}$: sintesi del progetto da sviluppare;
	\item finalità del progetto: finalità richieste dal capitolato$_{\scaleto{G}{3pt}}$ d'appalto;
	\item tecnologie interessate: tecnologie che verranno utilizzate nello svolgimento del capitolato$_{\scaleto{G}{3pt}}$;
	\item aspetti positivi: aspetti favorevoli alla scelta del capitolato$_{\scaleto{G}{3pt}}$;
	\item criticità e fattori di rischio: problematiche che potrebbero sorgere durante lo svolgimento del capitolato;
	\item conclusioni: accettazione o rifiuto del capitolato$_{\scaleto{G}{3pt}}$ in base alle informazioni illustrate precedentemente e anche all'interesse dimostrato da ogni membro nel gruppo.
\end{itemize}
\subsection{Altra documentazione da fornire}\label{ProcessiPrimariFornituraAltraDocumentazioneDaFornire}
Oltre allo \textit{Studio di Fattibilità} vengono consegnati altri documenti all'azienda \textit{Sync Lab} ed ai committenti \textit{Prof. Tullio Vardanega} e \textit{Prof. Riccardo Cardin}. Questi documenti sono necessari al fine di tracciare le attività$_{\scaleto{G}{3pt}}$ di Analisi, Pianificazione, Verifica, Validazione e Controllo di Qualità per assicurare una completa trasparenza durante tutta la durata del ciclo di vita del progetto.
I documenti in questione sono:
\begin{itemize}
	\item \textit{Analisi dei Requisiti 2.0.0}: identifica e dettaglia in modo completo ed esaustivo i requisiti$_G$ del sistema descritto nel capitolato che il fornitore si impegna a soddisfare;
	\item \textit{Piano di Qualifica 2.0.0}: illustra la strategia complessiva di verifica e validazione proposta dal fornitore per pervenire al collaudo del sistema con la massima efficienza ed efficacia;
	\item \textit{Piano di Progetto 2.0.0}: presenta l'organigramma dettagliato del fornitore, lo schema proposto per l'assegnazione e la rotazione dei ruoli di progetto, l'impegno complessivo previsto per ogni ruolo e per ogni individuo, l'analisi dei rischi, la pianificazione di massima per la realizzazione del prodotto, e il corrispondente conto economico preventivo;
	\item \textit{Proof of Concept$_G$ e Technology Baseline$_G$}: il Proof of Concept$_{\scaleto{G}{3pt}}$ dimostra una baseline$_{\scaleto{G}{3pt}}$ per lo sviluppo del prodotto, mentre la Technology Baseline$_{\scaleto{G}{3pt}}$ definisce le tecnologie utilizzate. 
\end{itemize}
Alla documentazione appena illustrata il gruppo \textit{Jawa Druids} allegherà inoltre una lettera di presentazione con la quale si formalizza l'impegno nel portare al termine il capitolato prescelto entro i termini definiti nella lettera e rispettandone i requisiti$_{\scaleto{G}{3pt}}$ minimi.
\subsection{Strumenti}\label{ProcessiPrimariFornituraStrumenti}
Di seguito sono riportati gli strumenti impiegati dal gruppo durante il progetto per il processo di fornitura.
\subsubsection{Documenti Google}\label{ProcessiPrimariFornituraStrumentiDocumentiGoogle}
Questo strumento viene utilizzato per la realizzazione di documenti in cui più persone possono lavorarci contemporaneamente osservando le modifiche in tempo reale.
\begin{center}
	\url{https://docs.google.com}
\end{center}
\subsubsection{Fogli Google}\label{ProcessiPrimariFornituraStrumentiFogliGoogle}
Questo strumento viene utilizzato per la realizzazione di grafici e fogli di calcolo in cui più persone possono lavorarci contemporaneamente osservando le modifiche in tempo reale.
\begin{center}
	\url{https://www.google.com/sheets}
\end{center}


\section{Sviluppo}\label{ProcessiPrimariSviluppo}
\subsection{Scopo}\label{ProcessiPrimariScopo}
Il processo di sviluppo contiene tutte le attività$_{\scaleto{G}{3pt}}$ che riguardano la produzione del software richiesto dal cliente, in particolare analisi dei requisiti$_{\scaleto{G}{3pt}}$, design, codifica, integrazione, test e installazione.
\subsection{Descrizione}\label{ProcessiPrimariDescrizione}
Di seguito vengono elencate le varie attività$_{\scaleto{G}{3pt}}$ che caratterizzano tale processo:
\begin{itemize}
	\item Analisi dei requisiti$_{\scaleto{G}{3pt}}$;
	\item Progettazione architetturale;
	\item Codifica del software.
\end{itemize}
\subsection{Prospettive}\label{ProcessiPrimariProspettive}
Le prospettive alla fine della stesura del processo in questione sono le seguenti:
\begin{itemize}
	\item individuare e stabilire gli obbiettivi di sviluppo;
	\item individuare e stabilire i vincoli tecnologici;
	\item individuare e stabilire i vincoli di design;
	\item produrre un prodotto finale che rispecchi gli obiettivi imposti nello sviluppo e che superi i test e i controlli di qualità stabiliti dal proponente$_{\scaleto{G}{3pt}}$.
\end{itemize}
\subsubsection{Analisi dei requisiti}\label{ProcessiPrimariProspettiveAnalisiDeiRequisiti}
\paragraph{Scopo}\label{ProcessiPrimariProspettiveAnalisiDeiRequisitiScopo}\mbox{}\\
L'analisi dei requisiti$_{\scaleto{G}{3pt}}$ viene redatto dagli \textit{Analisti}, lo scopo è quello di definire le funzionalità che il nuovo prodotto deve offrire, ovvero i requisiti$_{\scaleto{G}{3pt}}$ che devono essere soddisfatti dal software sviluppato.\\
Gli obiettivi della stesura dell'\textit{Analisi dei Requisiti} sono:
\begin{itemize}
	\item stabilire lo scopo nello sviluppo del prodotto;
	\item definire riferimenti precisi ed affidabili ai \textit{Progettisti};
	\item stabilire i requisiti$_{\scaleto{G}{3pt}}$ e le funzionalità concordate con il cliente;
	\item individuare per i \textit{Verificatori} riferimenti per le attività$_{\scaleto{G}{3pt}}$ di controllo dei test.
\end{itemize}
\paragraph{Descrizione}\label{ProcessiPrimariProspettiveAnalisiDeiRequisitiDescrizione}\mbox{}\\
I requisiti$_{\scaleto{G}{3pt}}$ possono essere individuati in diverse fonti, quali:
\begin{itemize}
	\item \textit{Capitolato$_{\scaleto{G}{3pt}}$ d'Appalto}: i requisiti$_{\scaleto{G}{3pt}}$ sono stati individuati attraverso la lettura del documento fornito dal proponente$_{\scaleto{G}{3pt}}$ \textit{Sync Lab} sul capitolato proposto;
	\item \textit{Verbali Interni}: attraverso le riunioni attuate internamente dagli \textit{Analisti} sono emersi vari requisiti$_{\scaleto{G}{3pt}}$;
	\item \textit{Verbali Esterni}: attraverso contatti e discussioni effettuate con il responsabile aziendale Fabio Pallaro sono emersi requisiti$_{\scaleto{G}{3pt}}$, i quali vi sarà assegnato un codice presente nella tabella dei tracciamenti.
\end{itemize}
\paragraph{Prospettive}\label{ProcessiPrimariProspettiveAnalisiDeiRequisitiProspettive}\mbox{}\\
L'obiettivo dell'\textit{Analisi dei Requisti} è quello di redigere un documento che racchiuda al suo interno tutti i requisiti$_{\scaleto{G}{3pt}}$ richiesti dal proponente$_{\scaleto{G}{3pt}}$.
\paragraph{Struttura}\label{ProcessiPrimariProspettiveAnalisiDeiRequisitiStruttura}\mbox{}\\ %wip non è ancora perfettamente definito ???
L'\textit{Analisi dei requisiti$_{\scaleto{G}{3pt}}$} è strutturato nel seguente modo:
\begin{itemize}
	\item \textbf{Introduzione}: in questa sezione si introduce lo scopo del documento e riferimenti a documenti esterni;
	\item \textbf{Descrizione generale}: il prodotto viene descritto, si individuano le fasi generali del progetto e l'utenza a cui è destinato il prodotto;
	%\item \textbf{Fasi del prodotto}: si elencano in gruppi le fasi del progetto, le quali vengono suddivise in parti per individuare più dettagliatamente tutti i processi di sviluppo del software;
	\item \textbf{Casi d'uso$_{\scaleto{G}{3pt}}$}: si elencano tutti i casi d'uso$_{\scaleto{G}{3pt}}$ individuati, questo è utile al tracciamento dei requisiti e permette di individuare tutte le funzionalità del progetto;
	\item \textbf{Requisiti$_{\scaleto{G}{3pt}}$}: utilizzando i casi d'uso descritti e tutti i documenti sopra indicati si dettagliano tutti i requisiti$_{\scaleto{G}{3pt}}$ obbligatori, facoltativi e desiderabili da implementare.
\end{itemize}
\paragraph{Classificazione dei requisiti}\label{ProcessiPrimariProspettiveAnalisiDeiRequisitiClassificazioneDeiRequisiti}\mbox{}\\% RS1.2 = rs(requisiti specifici) 1(fase generale a cui si riferiscono) 2(numero del requisito incrementale)
I requisiti$_{\scaleto{G}{3pt}}$ sono stati individuati utilizzando la seguente codifica:
\begin{center}
	\textbf{RS[classificazione][tipo\_di\_requisito][codice\_requisito]}
\end{center}
La descrizione della classificazione è la seguente:
\begin{itemize}
	\item \textbf{RS}: è l'acronimo per Requisito$_{\scaleto{G}{3pt}}$ Specifico;
	\item \textbf{Classificazione}: individua la classificazione del requisito$_{\scaleto{G}{3pt}}$:
	\begin{itemize}
		\item Funzionale: indicato dalla lettera "F";
		\item Qualità: indicato dalla lettera "Q";
		\item Vincolo: indicato dalla lettera "V";
		\item Prestazionale: indicato dalla lettera "P".
	\end{itemize}
	\item \textbf{Tipo\_di\_requisito$_{\scaleto{G}{3pt}}$}: individua la tipologia di requisito$_{\scaleto{G}{3pt}}$:
	\begin{itemize}
		\item Obbligatorio: indicato con la lettera "O" individua un requisito$_{\scaleto{G}{3pt}}$ essenziale allo sviluppo del progetto e necessario al suo completamento;
		\item Desiderabile: indicato con la lettera "D" individua un requisito$_{\scaleto{G}{3pt}}$ utile al prodotto e che dà valore aggiunto ad esso, ma non essenziale al suo completamento;
		\item Facoltativo: indicato con la lettera "F" individua un requisito$_{\scaleto{G}{3pt}}$ che può essere sviluppato, ma può anche non essere completato.
	\end{itemize}
	\item \textbf{Codice\_requisito}: è rappresentato da un codice identificativo univoco nella forma gerarchica padre/figlio.
\end{itemize}
Ogni requisito$_{\scaleto{G}{3pt}}$ è strutturato nella tabella nel seguente modo:
\begin{itemize}
	\item \textbf{Identificativo}: individua univocamente il requisito$_{\scaleto{G}{3pt}}$;
	\item \textbf{Descrizione}: descrizione del requisito$_{\scaleto{G}{3pt}}$; % richiesto nella determinata fase;
	\item \textbf{Tipo di requisito$_{\scaleto{G}{3pt}}$}: individua la tipologia di requisito$_{\scaleto{G}{3pt}}$ obbligatorio, desiderabile e facoltativo;
	\item \textbf{Fonte}: ogni requisito$_{\scaleto{G}{3pt}}$ è ricavato da una delle seguenti fonti:
	\begin{itemize}
		\item Capitolato$_{\scaleto{G}{3pt}}$: individua il documento del capitolato$_{\scaleto{G}{3pt}}$;
		\item Interno: il requisito$_{\scaleto{G}{3pt}}$ è stato individuato dagli analisti;
		\item Verbale: si tratta del documento in riferimento alla discussione con il proponente$_{\scaleto{G}{3pt}}$;
		\item Casi d'uso$_{\scaleto{G}{3pt}}$: il requisito$_{\scaleto{G}{3pt}}$ è stato individuato dal caso d'uso$_{\scaleto{G}{3pt}}$ individuato con il proprio codice.
	\end{itemize}
\end{itemize}
\begin{comment}
	\paragraph{Classificazione delle fasi}\label{ProcessiPrimariProspettiveAnalisiDeiRequisitiClassificazioneDelleFasi}\mbox{}\\% FC1.2 = fc(fasi capitolato) 1 (macro-fase) 2(fase precisa)
	La descrizione dettagliata delle fasi è stata incorporata nel documento per individuare la fase in cui il requisito$_{\scaleto{G}{3pt}}$ è necessario che venga implementato o sia possibile l'implementazione.\\
	La classificazione delle fasi è definita nel seguente modo:
	\begin{center}
	\textbf{FC[codice\_macro-fase].[codice\_fase]}
	\end{center}
	La descrizione della classificazione è la seguente:
	\begin{itemize}
	\item \textbf{FC}: è l'acronimo per Fasi Capitolato$_{\scaleto{G}{3pt}}$;
	\item \textbf{Codice\_macro-fase}: individua un numero riferito alla fase dello sviluppo del progetto;
	\item \textbf{Codice\_fase}: individua un numero riferito ad una suddivisione della fase del progetto.
	\end{itemize}
	Ogni suddivisione delle fasi è strutturato nel seguente modo:
	\begin{itemize}
	\item \textbf{Principali}:
	\begin{itemize}
	\item \textbf{Identificativo}: inserito prima del nome della fase per individuarla univocamente;
	\item \textbf{Nome}: identifica il nome della fase;
	\item \textbf{Descrizione}: descrizione dello scopo della fase in analisi.
	\end{itemize}
	\item \textbf{Aggiuntivi}:
	\begin{itemize}
	\item \textbf{Input}: dati in ingresso necessari allo sviluppo della fase;
	\item \textbf{Output}: dati in uscita elaborati o modificati durante la fase;
	\item \textbf{Linguaggio di programmazione}: linguaggio di programmazione utilizzato per lo sviluppo della fase;
	\item \textbf{Processo}: sono le operazioni svolte nella fase;
	\item \textbf{Risposta ad errori}: operazione della fase nel caso di errori;
	\item \textbf{Tipi di algoritmi}: individua gli algoritmi utilizzabili;
	\item \textbf{Strumenti}: sono strumenti utilizzati nello svolgimento della fase;
	\item \textbf{Vincolo}: vincoli individuati dal gruppo o dal proponente$_{\scaleto{G}{3pt}}$.
	\end{itemize}
	\end{itemize}

\end{comment}


%----------Casi d'uso nuovi---------------------%
\paragraph{Classificazione dei casi d'uso}\label{ProcessiPrimariProspettiveAnalisiDeiRequisitiClassificazioneDeiCasiDuso}
I casi d'uso$_{\scaleto{G}{3pt}}$ individuano le iterazioni tra il sistema ed un attore. I casi d'uso$_{\scaleto{G}{3pt}}$ vengono identificati nel seguente modo:
\begin{center}
	\textbf{UC[codice\_Padre].[codice\_Figlio]}
\end{center}
La descrizione della classificazione è la seguente:
\begin{itemize}
	\item \textbf{FC}: è l'acronimo per User Case$_{\scaleto{G}{3pt}}$, la parola inglese che si traduce in Casi D'uso$_{\scaleto{G}{3pt}}$;
	\item \textbf{Codice\_Padre.Codice\_Figlio}: individua un codice univoco per ogni caso d'uso$_{\scaleto{G}{3pt}}$ nella forma gerarchica padre/figlio;
\end{itemize}
Ogni caso d'uso$_{\scaleto{G}{3pt}}$ si struttura nel seguente modo:
\begin{itemize}
	\item \textbf{Principali}:
	\begin{itemize}
		\item \textbf{Attori}: definisce una persona o un elemento esterno che interagisce con il sistema per avviare il caso d'uso$_{\scaleto{G}{3pt}}$;
		\item \textbf{Descrizione}: breve descrizione del caso d'uso$_{\scaleto{G}{3pt}}$;
		\item \textbf{Scenario principale}: descrive le azioni necessarie al completamento del caso d'uso$_{\scaleto{G}{3pt}}$;
		\item \textbf{Precondizione}: individua le condizioni necessarie per l'avvio del caso d'uso$_{\scaleto{G}{3pt}}$;
		\item \textbf{Postcondizione}: individua le condizioni del sistema al completamento del caso d'uso$_{\scaleto{G}{3pt}}$.
		%or identify the items that the use case must handle before terminating%
	\end{itemize}
	\item \textbf{Aggiuntivi}:
	\begin{itemize}
		\item \textbf{Input}: individua file da inserire nel sistema da parte dell'attore;
		\item \textbf{Output}: Individua file in uscita dal sistema per l'attore;
		\item \textbf{Estensioni}: individua le condizioni nel quale viene utilizzato un caso d'uso$_{\scaleto{G}{3pt}}$ esterno, tale che aumenti le funzionalità del caso d'uso$_{\scaleto{G}{3pt}}$ sotto osservazione;
		%An extension point is a feature of a use case which identifies (references) a point in the behavior of the use case where that behavior can be extended by some other (extending) use case, as specified by extend relationship%
		\item \textbf{Generalizzazioni}: individua la generalizzazione del caso d'uso$_{\scaleto{G}{3pt}}$ in sotto casi figli;
		\item \textbf{Inclusioni}: individuano altri casi d'uso$_{\scaleto{G}{3pt}}$ che vengono utilizzati per compiere il caso d'uso$_{\scaleto{G}{3pt}}$ in osservazione.
	\end{itemize}
\end{itemize}

%---------Fine casi d'uso----------------------%
\paragraph{Qualità dei requisiti}\label{ProcessiPrimariProspettiveAnalisiDeiRequisitiQualitàDeiRequisiti}\mbox{}\\
Ogni requisito$_{\scaleto{G}{3pt}}$ deve rispettare le seguenti qualità:
\begin{itemize}
	\item devono essere correttamente descritti;
	\item non devono essere ambigui, ogni requisito$_{\scaleto{G}{3pt}}$ fornirà un'unica interpretazione;
	\item devono essere completi, cioè descrivere in modo completo e in tutte le sue parti la funzionalità da implementare;
	\item ogni requisito$_{\scaleto{G}{3pt}}$ deve essere consistente, cioè non deve avere conflitti con altri requisiti$_{\scaleto{G}{3pt}}$ individuati;
	\item devono essere modificabili, cioè ogni requisito$_{\scaleto{G}{3pt}}$ nel corso dello sviluppo del progetto può essere rivalutato e modificato e bisogna mantenere uno storico dei cambiamenti;
	\item ogni requisito$_{\scaleto{G}{3pt}}$ deve essere tracciabile, cioè ogni requisito$_{\scaleto{G}{3pt}}$ deve essere tracciabile ad ogni suo test o codice di implementazione o alla sua origine;
	\item ogni requisito$_{\scaleto{G}{3pt}}$ deve essere classificato per importanza o stabilità;
	\item ogni requisito$_{\scaleto{G}{3pt}}$ deve essere verificabile, cioè deve essere possibile una sua verifica attraverso un processo nel quale una persona o una macchina può controllarlo.
\end{itemize}

\paragraph{Metriche}\label{ProcessiPrimariProspettiveAnalisiDeiRequisitiMetriche}\mbox{}\\
Con \textbf{MQPD01} si intende la \textbf{Totalità delle implementazioni}. Indice riportante l'interezza del prodotto software, rispetto ai requisiti$_{\scaleto{G}{3pt}}$ posti, mediante un valore percentuale.:

\begin{center}
	\textbf{T=($1-\frac{RnI}{RI}$)*100}
\end{center}
Dove:
\begin{itemize}
	\item \textbf{T} sta per \textit{Totalità}, riferito ai requisiti$_{\scaleto{G}{3pt}}$ da implementare;
	\item \textbf{RnI} sta per \textit{Requisito$_{\scaleto{G}{3pt}}$ non Implementato};
	\item \textbf{RI} sta per \textit{Requisito$_{\scaleto{G}{3pt}}$ Implementato}.
\end{itemize}
I range accettabili per il risultato di \textbf{T} sono così suddivisi:
\begin{itemize}
	\item 90\% $<$ \textbf{T} $\leq$ 100\% indica che la copertura dei requisiti$_{\scaleto{G}{3pt}}$ proposti è quasi totale;
	\item 80\% $<$ \textbf{T} $\leq$ 90\% indica che la copertura dei requisiti$_{\scaleto{G}{3pt}}$ proposti è sufficiente, buona;
	\item \textbf{T} $\leq$ 80\% indica che la copertura dei requisiti$_{\scaleto{G}{3pt}}$ proposti è insufficiente.
\end{itemize}


\subsection{Progettazione}\label{ProcessiPrimariProgettazione}
\subsubsection{Scopo}\label{ProcessiPrimariProgettazioneScopo}
La Progettazione è un'attività$_{\scaleto{G}{3pt}}$ svolta dai \textit{Progettisti}, nella quale si individuano, tramite l'\textit{Analisi dei Requisiti 2.0.0}, le caratteristiche che il prodotto deve avere per soddisfare tutti i requisiti$_{\scaleto{G}{3pt}}$ richiesti dal proponente$_{\scaleto{G}{3pt}}$. Lo scopo è quello di determinare la soluzione migliore per assolvere ogni requisito$_{\scaleto{G}{3pt}}$ individuato.
\subsubsection{Aspettative}\label{ProcessiPrimariProgettazioneAspettative}
Precedentemente alla realizzazione dell'architettura del sistema dovranno essere definite:
\begin{itemize}
	\item le tecnologie da utilizzare;
	\item i vincoli strutturali richiesti dal proponente;
	\item il Proof of Concept$_{\scaleto{G}{3pt}}$, cioè una bozza eseguibile del prodotto che individui lo studio svolto in preparazione all'architettura da implementare. 
\end{itemize}
Alla conclusione della stesura della progettazione si ha come risultato la realizzazione dell'architettura del software da sviluppare. Tale architettura è necessaria ai programmatori per individuare le istruzioni necessarie a sviluppare il prodotto finito. 
\subsubsection{Descrizione}\label{ProcessiPrimariProgettazioneDescrizione}
La progettazione prevede inizialmente la realizzazione del Proof of Concept$_{\scaleto{G}{3pt}}$ della Technology Baseline$_{\scaleto{G}{3pt}}$, che, successivamente, viene approfondito e redatto nel documento tecnico allegato alla Product Baseline$_{\scaleto{G}{3pt}}$. La progettazione segue l'\textit{Analisi dei Requisiti 2.0.0}: infatti, se l'Analisi è l'espansione del problema e l'identificazione delle parti che lo compongono per l'individuazione del dominio applicativo, allora la progettazione è il procedimento inverso, cioè si trova un modo per collegare tutte le parti assieme, specificando le funzionalità di tutti i sottosistemi e raggiungendo così un'unica soluzione.
%\begin{itemize}
%	\item \textbf{Technology baseline$_G$}: contiene tutte le specifiche adottate nella progettazione ad alto livello e delle sue componenti, i test di verifica e l'elenco dei diagrammi UML$_G$ utilizzati per la definizione dell'architettura;
%	\item \textbf{Product baseline$_G$}: perfeziona ulteriormente la fase di progettazione, integrando ciò che è riportato nella technology baseline$_{\scaleto{G}{3pt}}$, definendo inoltre i test necessari alla verifica.
%\end{itemize}
%
%\subsubsection{Technology baseline}\label{ProcessiPrimariProgettazioneTecnologyBaseline}
%La technology baseline$_{\scaleto{G}{3pt}}$ viene redatta dal \textit{Progettista} ed include:
%\begin{itemize}
%	\item \textbf{Diagramma UML$_{\scaleto{G}{3pt}}$}: diagrammi sulle classi usate, package, attività$_{\scaleto{G}{3pt}}$ e sequenze;
%	\item \textbf{Tecnologie}: descrizione delle tecnologie utilizzate nel progetto, i loro vantaggi e svantaggi;
%	\item \textbf{Design pattern}: descrizione di ogni design pattern per la realizzazione dell'architettura, ognuno di essi viene accompagnato da un diagramma che ne espone il significato e la struttura;
%	\item \textbf{Tracciamento delle componenti}: ogni componente viene riferito al requisito$_{\scaleto{G}{3pt}}$ che soddisfa;
%	\item \textbf{Test di integrazione}: corrispondono a tutti i test necessari alla verifica del sistema in tutte le sue unità.
%\end{itemize}
%\subsubsection{Product baseline}\label{ProcessiPrimariProgettazioneProductBaseline}
%La product baseline$_{\scaleto{G}{3pt}}$ viene redatta dal \textit{Progettista} ed include:
%\begin{itemize}
%	\item \textbf{definizioni delle classi e funzioni}: descrizione univoca delle classi e funzioni evitando ridondanze;
%	\item \textbf{tracciamento}: ogni requisito$_{\scaleto{G}{3pt}}$ viene tracciato attraverso le classi e funzioni, questo è necessario per individuare se è stato soddisfatto il requisito$_{\scaleto{G}{3pt}}$;
%	\item \textbf{test di unità}: definiscono test per la verifica delle funzionalità del prodotto.
%\end{itemize}
\subsubsection{Qualità dell'architettura}\label{ProcessiPrimariProgettazioneQualitaArchitettura}
L'architettura del progetto viene definita dai \textit{Progettisti} per individuare una logica corretta allo sviluppo del prodotto. Ogni modulo definito all'interno dell'architettura deve essere identificabile in modo chiaro e riusabile.
L'architettura dovrà rispettare delle caratteristiche per raggiungere una qualità adeguata:
\begin{itemize}
	\item dovrà soddisfare i requisiti identificati nel documento \textit{Analisi dei Requisiti 2.0.0} e poter essere modulabile nel caso essi vengano modificati o aggiunti;
	\item dovrà essere capita dagli stakeholders$_{\scaleto{G}{3pt}}$ e quindi dovrà essere fatta una stesura chiara e comprensibile con il tracciamento sui requisiti annesso;
	\item dovrà poter mantenere un grado di funzionamento adeguato anche in caso di situazioni erronee improvvise;
	\item dovrà essere possibile applicare modifiche a costi ridotti in caso i requisiti vengano modificati o evoluti;
	\item dovrà essere modellata in modo tale da poter riutilizzare alcune delle sue parti;
	\item dovrà comprendere tutti i requisiti e soddisfarli in modo da eliminare sprechi di tempo e spazio;
	\item dovrà svolgere tutti i suoi compiti al suo utilizzo;
	\item dovrà essere sicura e la sua manutenzione dovrà avvenire in tempo ridotti cosicché da garantire un servizio di funzionamento il più continuo possibile;
	\item dovrà essere semplice ed evitare la complessità introducendo solo il necessario. %???%
\end{itemize} 

\subsubsection{Attività di progettazione}\label{ProcessiPrimariProgettazioneAttivita}
Le attività da svolgere durante il progetto sono suddivise per obiettivi da raggiungere e rientrano nello specifico arco temporale definito nel  \textit{Piano di Progetto 2.0.0}. Consistono in progettazione architetturale, progettazione dettagliata e codifica, durante i quali verranno affrontate la Technology Baseline$_{\scaleto{G}{3pt}}$ e la Product Baseline$_{\scaleto{G}{3pt}}$,
\begin{itemize}
	\item \textbf{Progettazione architetturale} \\ \\
	Durante questo periodo vengono definiti i componenti del sistema, ovvero i task da eseguire per completare con successo il periodo.
	\begin{itemize}
		\item identificazione delle componenti coinvolte nel sistema;
		\item organizzazione dei ruoli, responsabilità e interazioni di ogni componente;
		\item definizione delle interazioni tra le componenti tra loro e con l’ambiente;
		\item creazione e documentazione dei test di integrazione all’interno del \textit{Piano di Qualifica 2.0.0}.
	\end{itemize}
	\end{itemize}

\begin{itemize}
	\item \textbf{Progettazione di dettaglio} \\ \\
	Le parti sono suddivise per determinare cosa dovrà fare il codice nel particolare, in modo da assegnare compiti indivisibili ai Programmatori.
	\begin{itemize}
		\item definizione degli strumenti di verifica per le \textbf{unità} e per i \textbf{moduli};
		\item definizione dei ruoli che coinvolgono rispettivamente le \textbf{unità} e i \textbf{moduli};
		\item definizione delle interazioni che coinvolgono le \textbf{unità};
		\item suddivisione delle componenti individuate in \textbf{unità};
		\item definizione dell'\textbf{unità} come insieme dei \textbf{moduli}.
	\end{itemize}
\end{itemize}
%??? da continuare%

\subsubsection{Diagrammi UML 2.0}\label{ProcessiPrimariProgettazioneUML}
L'utilizzo dei diagrammi UML 2.0 è necessario per rendere più chiare le scelte progettuali adottate. I diagrammi che verranno utilizzati sono:
\begin{itemize}
	\item \textbf{diagrammi dei package$_{\scaleto{G}{3pt}}$}: descrivono graficamente le dipendenze tra diversi package all'interno del sistema, i package sono raggruppamenti di classi in unià;
	\item \textbf{diagrammi delle classi}: rappresentano graficamente un modello astratto delle classi in descrizione e le loro realzioni, ogni classe viene individuata dai suoi attributi, il suo tipo e i suoi metodi;
	\item \textbf{diagrammi delle attività}: illustra graficamente la sequenza di attività per raggiungere un obiettivo da uno stato iniziale, essi possono descrivere la logica di un algoritmo; %???%
	\item \textbf{diagrammi dei casi d'uso}: descrivono le funzionalità che il sistema offre;
	\item \textbf{diagrammi di sequenza}: rappresentano l'interazione logica tra diverse classi/oggetti;
\end{itemize}

\paragraph{Diagrammi dei package:}  \label{ProcessiPrimariProgettazioneUMLDiagrammiDeiPackage}
Ogni package$_{\scaleto{G}{3pt}}$ viene individuato tramite un rettangolo con un'etichetta per il nome. Il package$_{\scaleto{G}{3pt}}$ contiene al suo interno i diagramma delle classi relative al package$_{\scaleto{G}{3pt}}$ e possibili sotto-package$_{\scaleto{G}{3pt}}$. Le dipendenze tra i package$_{\scaleto{G}{3pt}}$ vengono rappresentate attraverso una freccia tratteggiata che collega due package$_{\scaleto{G}{3pt}}$. Si dovrà evitare che le dipendenze dei package$_{\scaleto{G}{3pt}}$ così collegati formino una dipendenza ciclica.

\begin{figure}
		\centering\includegraphics{../immagini/normeUML/pk_uml.png}
		\caption{Rappresentazione grafica dei diagrammi dei package}
\end{figure}
\paragraph{Diagrammi delle classi:}\label{ProcessiPrimariProgettazioneUMLDiagrammiDelle Classi} 
Le classi vengono individuate da un rettangolo suddiviso in tre sezioni orizzontali. Ciascuna sezione partendo dall'alto individuano:
\begin{enumerate}
	\item \textbf{Nome della classe}: deve essere univoco ed esplicativo. Il nome sarà scritto in lingua inglese, se la classe raffigurata è una classe astratta il suo nome verrà preceduto da $<<abstract>>$, mentre se è un'interfaccia verrà preceduto da $<<interface>>$.
	\item \textbf{Attributi}: ogni attributo individua una variabile della classe. Gli attributi vengono scritti uno dopo l'altro sotto forma di lista. Ogni attributo sarà scritto nel seguente modo:
	\begin{center}
		\textbf{nomeAttributo : tipo}
	\end{center}
	La descrizione della scrittura degli attributi è la seguente:
	\begin{itemize}
		\item \textbf{nomeAttributo}: individua il nome della variabile, deve essere scritta in lingua inglese e con la lettera iniziale minuscola. Nel caso sia una variabile costante tutto il nome deve essere scritto in maiuscolo;
		\item \textbf{tipo}: il tipo può essere semplice o definito da una classe creata dall'utente.
	\end{itemize}
	Ogni attributo viene preceduto obbligatoriamente da un operatore:
	\begin{itemize}
		\item \textbf{$+$}: indica la visibilità pubblica della variabile;
		\item \textbf{$-$}: indica la visibilità privata della variabile;
		\item \textbf{$\#$}: indica la visibilità protetta della variabile;
		\item \textbf{$\thicksim$}: indica la visibilità package della variabile.
	\end{itemize}
	\item \textbf{Metodi}: indicano i metodi della classe, vengono disposti in lista uno dopo l'altro. I metodi vengono scritti nel seguente modo:
	\begin{center}
		\textbf{nomeMetodo (lista-param) : tipoR}
	\end{center}
	La descrizione della scrittura dei metodi è la seguente:
	\begin{itemize}
		\item \textbf{nomeMetodo}: individua il nome del metodo, deve essere univoco ed in lingua inglese;
		\item \textbf{lista-param}: indica la lista dei parametri formali del metodo che può essere composta da 0 o più parametri, ogni parametro è separato da una virgola con il successivo e sono scritti nel formato \textit{nome : tipo};
		\item \textbf{tipoR}: individua il tipo dell'oggetto di ritorno, può essere semplice o definito dall'utente.
	\end{itemize}
	Ogni metodo sarà preceduto dagli operatori di visibilità descritti precedentemente. Se il metodo sotto osservazione è un metodo astratto il suo nome viene preceduto da $<<abstract>>$, mentre se è statico da $<<static>>$.
\end{enumerate}
Il collegamento tra i diagrammi delle classi viene effettuato con delle frecce che illustrano le dipendenze.
I tipi di frecca vengono descritti di seguito:
\begin{itemize}
	\item freccia normale, da classe 1 a classe 2: indica che gli oggetti delle due classi consividono una relazione statica;
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/frecSempl.png}
		\caption{Relazione di associazione tra classe 1 e classe 2}
	\end{figure}
	 
	\item freccia tratteggiata, da classe 1 a classe 2: indica che la definizione di una delle due classi fa riferimento alla definizione dell'altra;
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/frecTrat.png}
		\caption{Relazione di dipendenza tra classe 1 e classe 2}
	\end{figure}
	\item freccia "a diamante" vuoto, da classe 1 a classe 2: indica una relazione del tipo "è parte di", cioè classe 2 è parte di classe 1, questo permette di aggregare più classi e creare una classe più complessa;
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/frecDiamVuot.png}
		\caption{Relazione di aggregazione tra classe 1 e classe 2}
	\end{figure}
	\item freccia "a diamante" piena, da classe 1 a classe 2: indica la composizione, è simile all'aggregazione, ma ha una relazione più forte sulla classe sub-ordinata perchè classe 2 non può esistere la classe 1;
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/frecDiamPien.png}
		\caption{Relazione di composizione tra classe 1 e classe 2}
	\end{figure}
	\item freccia con punta vuota, da classe 1 a classe 2: indica la realizzazione/implementazione, cioè l'oggetto classe 1 implementa il comportamento, quindi nel nostro caso i metodi, che l'oggetto classe 2 specifica. 
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/frecInter.png}
		\caption{Relazione di interfaccie tra classe 1 e classe 2}
	\end{figure}
\end{itemize}
Ad ogni freccia di collegamento viene indicato la molteplicità che ha e vengono indicate nel seguente modo:
\begin{itemize}
	\item \textbf{1}: classe 1 possiede un'istanza di classe 2;
	\item \textbf{0...1}: classe 1 può possedere al massimo una istanza di classe 2;
	\item \textbf{0...*} classe 1 può possedere 0 o più istanze della classe 2;
	\item \textbf{*}: classe 1 può possedere più istanze della classe 2;
	\item \textbf{n}: classe 1 possiede $n$ istanze della classe 2.
\end{itemize}
\paragraph{Diagrammi delle attività:}\label{ProcessiPrimariProgettazioneUMLDiagrammiDellAttività} 
Il diagramma di attività è un tipo di diagramma che permette di descrivere un processo attraverso dei grafi in cui i nodi rappresentano le attività e gli archi l'ordine con cui vengono eseguite. I diagrammi vengono illustrati usando il seguente formalismo:
\begin{itemize}
	\item \textbf{Nodo iniziale}: viene rappresentato da un pallino nero pieno ed indica l'inizio della attività dove viene generato un token;
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/nodoIni.png}
		\caption{Rappresentazione di un nodo iniziale}
	\end{figure}
	\item \textbf{Attività}: viene rappresentata da un rettangolo, la sua descrizione deve essere breve e significativa per indicare l'azione svolta in quel punto del flusso dell'attività. Consuma e produce un token;
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/attivita.png}
		\caption{Rappresentazione di una attività}
	\end{figure}
	\item \textbf{Nodo finale}: viene rappresentato da due cerchi concentrici di cui l'esterno è vuoto e quello interno è pieno. Indica il punto in cui termina l'esecuzione. Consuma un token;
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/nodoFine.png}
		\caption{Rappresentazione di un nodo finale}
	\end{figure}
	\item \textbf{Nodo di fine flusso}: viene rappresentato attraverso un cerchio vuoto con una $X$ al centro. Indica la terminazione di un ramo dell'attività. Consuma un token;
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/nodoFineFlusso.png}
		\caption{Rappresentazione di un nodo di fine flusso}
	\end{figure}
	\item \textbf{Sotto-attività}: viene rappresentata da un rettangolo con un tridente nell'angolo in basso a destra. Indica che l'attività viene rappresentata in un diagramma separato ed ogni sotto-attività ha un input ed un output;
	\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/attSott.png}
		\caption{Rappresentazione di una sotto-attività}
	\end{figure}
	\item \textbf{Branch}: viene rappresentato attraverso un rombo con una freccia in entrata e $n$ frecce in uscita. Ogni ramo in uscita deve avere una guardia, scritta nel formato $[guardia]$. Il branch definisce una scelta, tra i rami disponibili in usciti se ne può scegliere uno solo in base alla guardia. Consuma e produce un token;
	\item \textbf{Merge}: viene rappresentato da un rombo con $n$ frecce in entrata e una freccia in uscita. Individua il punto in cui i rami creati dal Branch tornano ad unirsi. Consuma e produce un token;
		\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/mergeBranch.png}
		\caption{Rappresentazione di un branch e merge}
	\end{figure}
	\item \textbf{Fork}: viene rappresentato da una linea nera marcata orizzontale o verticale. Indica il punto in cui avviene una paralizzazione delle attività da effettuare senza un limite temporale. Il fork presenta una freccia in entrata e $n$ frecce in uscita. Consuma e produce un token;
	\item \textbf{Join}: viene rappresentato da una linea nera marcata orizzontale o verticale. Indica il punto in cui tutte le attività svolte in parallelo si sincronizzano. Il join preseta $n$ frecce in entrata e una freccia in uscita. Consuma e produce un token;
		\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/forkJoin.png}
		\caption{Rappresentazione di un fork e un join}
	\end{figure}
	\item \textbf{Pin}: viene rappresentato da un quadrato con una freccia al suo interno nella direzione di input o output. Indica il parametro che viene inviato da un'attività all'altra, a fianco del quadrato viene scritto il tipo di parametro inviato;
		\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/pin.png}
		\caption{Rappresentazione di pin in un'attività}
	\end{figure}
	\item \textbf{Segnali}: rappresentate da due figure "a incastro", la prima utilizzata per l'emissione del segnale, la seconda per la ricezione dello stesso. Il testo di descrizione all'interno delle figure deve essere breve e conciso e deve avere un prefisso $-signal sending-$ o $-signal receipt-$ a secondo della figura in descrizione;
		\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/signal.png}
		\caption{Rappresentazione di un segnale}
	\end{figure}
	\item \textbf{Timeout}: viene rappresentato da una clessidra stilizzata. Indica due tipi di eventi uno è il timeout rappresentato dalla clessidra con una freccia entrante e uscente, serve a rappresentare un'attesa di tempo. L'altro tipo di evento è l'evento ripetuto, rappresentato da una clessidra con una freccia in uscita, serve ad indicare un'azione ripetuta. %??? immagini%
		\begin{figure}[H]
		\centering\includegraphics{../immagini/normeUML/timeout.png}
		\centering\includegraphics{../immagini/normeUML/reapeate.png}
		\caption{Rappresentazione di un evento timeout e uno ripetuto}
	\end{figure}
\end{itemize}
\subsection{Codifica}\label{ProcessiPrimariCodifica}

\subsubsection{Scopo}\label{ProcessiPrimariCodificaScopo}
La fase di codifica è la scrittura del codice per sviluppare la miglior soluzione del prodotto. In questa sezione si introdurranno tutte le norme necessarie allo sviluppo di un codice uniformato tra tutti i \textit{Programmatori} e rispettoso delle regole standard indicate nel documento.
\subsubsection{Aspettative}\label{ProcessiPrimariCodificaAspettative}
Conclusa la fase di codifica ci si attende un codice pulito e facile da leggere, utile nelle successive validazioni, modifiche e per agevolare la sua manutenzione. L'obiettivo è quello di sviluppare un prodotto conforme alle richieste individuate con il proponente$_{\scaleto{G}{3pt}}$.

\subsubsection{Descrizione}\label{ProcessiPrimariCodificaDescrizione}
In questa fase la programmazione del prodotto dovrà rispettare le norme descritte nel documento. Perseguendo gli obiettivi individuati nel documento \textit{Piano di qualifica v1.0.0} si produrrà un software con un'alta qualità di codice.

\subsubsection{Intestazione} \label{ProcessiPrimariCodificaIntestazione}
Ciascun file di codifica dovrà riportare la seguente intestazione: 
\begin{center}
	\includegraphics[width=0.5\linewidth]{../immagini/CodificaIdentazione.png}
\end{center}


\subsubsection{Stile di codifica}\label{ProcessiPrimariCodificaStileDiCodifica}
All'interno di questo paragrafo vengono elencate le norme da rispettare da ogni membro del gruppo per raggiungere uniformità del codice:

\begin{itemize}
	\item \textbf{Indentazione}: ogni blocco di codice scritto per il prodotto da sviluppare deve essere ben indentato e deve rispettare per ciascun livello una misura di 4 spazi. E’ obbligatorio utilizzare gli spazi anzichè le tabulazioni (tasto tab). Per riuscire a rispettare tale obbligo si cosiglia di configurare in modo appropriato il proprio editor o IDE. Fanno eccezione a queste regole i commenti che vengono inseriti per spiegazioni di blocchi di codice;
	\item \textbf{Parentesizzazione}:  le parentesi devono essere utilizzate in linea col blocco di codice scritto e non in una linea sottostante, separandole con un singolo spazio;
	\item \textbf{Univocità delle classi, variabili, metodi e funzioni}: ogni classe, variabile, metodo e funzione utilizzata deve avere un nome significativo, esplicativo ed univoco;
	\item \textbf{Classi}: ogni classe deve avere il proprio nome scritto con l'iniziale maiuscola;
	\item \textbf{Metodi e funzioni}: il nome di metodi e funzioni devono iniziare per lettera minuscola e se composti da più parole le successive devono essere scritte con lettera maiuscola (stile \textit{CamelCase});
	\item \textbf{Commenti}: i commenti vanno inseriti solo nei casi in cui sono necessari per migliorare la comprensibilità e leggibilità del codice, mantenendo uno stile sintetico. Si possono utilizzare due tipologie di costrutti per i commenti:
	\begin{itemize}
		\item \textbf{/* ... */} per i commenti che racchiudono più di una riga, andare a capo dopo la dicitura /*  per scrivere il commento(????);
		\item \textbf{// … } per i commenti di linea singola che devono essere separati da uno spazio dopo la dicitura //.
	\end{itemize}
	Entrambi costrutti non devono essere riportati sulla stessa riga dell’istruzione a cui si riferiscono ma sulla riga che la precede;
	\item \textbf{Lingua}: il codice ed i commenti devono essere scritti in lingua inglese.
\end{itemize}

\subsection{Strumenti}\label{ProcessiPrimariStrumenti}

\subsubsection{PragmaDB}\label{ProcessiPrimariStrumentiPragmaDB}
Programma utilizzato per il tracciamento dei requisiti$_{\scaleto{G}{3pt}}$.
\begin{center}
	\url{https://pragmadb.com/}
\end{center}
\subsubsection{StarUML}\label{ProcessiPrimariStrumentiDrawIo}
Questo strumento viene usato per la realizzazione di diagrammi UML$_{\scaleto{G}{3pt}}$ in quanto è stato ritenuto semplice da utilizzare.
\begin{center}
	\url{https://staruml.io/}
\end{center}
\subsubsection{Atom}\label{ProcessiPrimariStrumentiAtom}
IDE che viene usato per la codifica del linguaggio Java e Javascript, oltre a supportare anche altri molteplici linguaggi di programmazione come Python, C, C++ e anche \LaTeX. Offre la piena compatibilità con Linux, Windows, macOS e fornisce molte integrazioni aggiuntive.
\begin{center}
	\url{https://atom.io}
\end{center}
\subsubsection{PyCharm}\label{ProcessiPrimariStrumentiPyCharm}
Si tratta di un IDE per programmare con il linguaggio Python.
Offre molteplici plugin.
\begin{center}
	\url{https://www.jetbrains.com/pycharm/}
\end{center}
\subsubsection{Google.Colab}\label{ProcessiPrimariStrumentiGoogleColab}
Colab, diminutivo di Colaboratory, è uno strumento online offerto da Google.
Mette a disposizione l'hardware di Google in modo da permettere a chiunque di poter testare script o modelli pesanti (es. Machine Learning$_{\scaleto{G}{3pt}}$) nel caso la propria macchina non ne fosse in grado.
Non prevede alcuna configurazione da parte dell'utente.
\begin{center}
	\url{https://colab.research.google.com/notebooks/}
\end{center}
\subsubsection{LeafLet}\label{ProcessiPrimariStrumentiLeafLet}
Utilizzato per la realizzazione delle Heat-map.
Si tratta di un Open-Source basato su Javascript.
\begin{center}
	\url{https://leafletjs.com/}
\end{center}
